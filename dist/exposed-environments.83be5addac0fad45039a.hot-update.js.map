{"version":3,"file":"exposed-environments.83be5addac0fad45039a.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyE;AAC1C;AACxB;AACP;AACA,WAAW,iDAAM;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,OAAO,YAAY;AACjE,OAAO;AACP;AACA,qCAAqC,QAAQ,OAAO,YAAY;AAChE,SAAS,SAAS;AAClB;AACA;AACA;AACO;AACP;AACO;AACP;AACA,yBAAyB,KAAK,kBAAkB,GAAG,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc,eAAe,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACM;AACP,uBAAuB,iDAAc,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,uFAAgB,IAAI,WAAW,OAAO,YAAY;AACvE;AACA;AACA;AACA;AACA,yBAAyB,uFAAgB,IAAI,QAAQ,OAAO,YAAY;AACxE;AACA,uBAAuB;AACvB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW,OAAO,YAAY;AACzE;AACA;AACA,OAAO;AACP;AACA;AACA,wCAAwC,QAAQ,OAAO,YAAY;AACnE,SAAS,SAAS;AAClB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAS;AACrB,wDAAwD;AACxD;AACA;AACA;AACA,+BAA+B,iDAAQ,CAAC,iDAAS,mBAAmB,iDAAK;AACzE;AACA,2BAA2B;AAC3B,gBAAgB,iDAAS;AACzB,wEAAwE;AACxE;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,mCAAmC,SAAS,GAAG,IAAI,EAAE,OAAO;AAC5D,OAAO;AACP;AACA,qCAAqC,OAAO,GAAG,IAAI,EAAE,OAAO;AAC5D,SAAS,SAAS;AAClB;AACA;AACA;AACO;AACP;AACA,4CAA4C,SAAS,cAAc,WAAW;AAC9E;AACA;AACO;AACP;AACA,aAAa,cAAc,sDAAsD,aAAa;AAC9F;AACA;AACO;AACP;AACA,0BAA0B,QAAQ,YAAY,SAAS,cAAc,WAAW,OAAO,YAAY,OAAO,QAAQ;AAClH;AACA","sources":["webpack://console-gitops-plugin/./components/utils/gitops-utils.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { consoleFetchJSON } from '@openshift-console/dynamic-plugin-sdk';\nimport * as _ from 'lodash-es';\nexport const getManifestURLs = (namespaces) => {\n    const annotation = 'app.openshift.io/vcs-uri';\n    return _.uniq(namespaces\n        .filter((ns) => {\n        var _a, _b;\n        return !!((_b = (_a = ns.metadata) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b[annotation]);\n    })\n        .map((ns) => {\n        var _a, _b;\n        return (_b = (_a = ns.metadata) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b[annotation];\n    }));\n};\nexport const getApplicationsListBaseURI = () => {\n    return `/api/gitops/applications`;\n};\n// export const fetchAppGroups = async (\n//   baseURL: string,\n//   manifestURL: string,\n// ): Promise<GitOpsAppGroupData[]> => {\n//   let data: GitOpsManifestData;\n//   try {\n//     const newListApi = getApplicationsListBaseURI();\n//     data = await coFetchJSON(`${newListApi}?url=${manifestURL}`);\n//   } catch (err) {\n//     try {\n//       data = await coFetchJSON(`${baseURL}&url=${manifestURL}`);\n//     } catch {} // eslint-disable-line no-empty\n//   }\n//   return data?.applications ?? [];\n// };\nexport class RetryError extends Error {\n}\nexport class TimeoutError extends Error {\n    constructor(url, ms, ...params) {\n        super(`Call to ${url} timed out after ${ms}ms.`); //Ã¥ ...params);\n        // Dumb hack to fix `instanceof TimeoutError`\n        Object.setPrototypeOf(this, TimeoutError.prototype);\n    }\n}\nconst initDefaults = {\n    headers: {},\n    credentials: 'same-origin',\n};\nconst cookiePrefix = 'csrf-token=';\nconst getCSRFToken = () => document &&\n    document.cookie &&\n    document.cookie\n        .split(';')\n        .map((c) => _.trim(c))\n        .filter((c) => c.startsWith(cookiePrefix))\n        .map((c) => c.slice(cookiePrefix.length))\n        .pop();\nexport const validateStatus = (response, url, method, retry) => __awaiter(void 0, void 0, void 0, function* () {\n    console.log('VALIDATE STATUS - RESPONSE STATUS IS ' + response.status);\n    console.log('VALIDATE STATUS - RESPONSE TEXT IS ' + response.text);\n    console.log('VALIDATE STATUS - RESPONSE BODY IS ' + response.body);\n    console.log('VALIDATE STATUS - RESPONSE formData IS ' + response.formData);\n    if (response.ok) {\n        return response;\n    }\n    // if (retry && response.status === 429) {\n    //   throw new RetryError();\n    // }\n    // if (response.status === 401 && shouldLogout(url)) {\n    //   authSvc.logout(window.location.pathname);\n    // }\n    // const contentType = response.headers.get('content-type');\n    // if (!contentType || contentType.indexOf('json') === -1) {\n    //   const error = new Error(response.statusText);\n    //   error.response = response;\n    //   throw error;\n    // }\n    // if (response.status === 403) {\n    //   return response.json().then((json) => {\n    //     const error = new Error(json.message || 'Access denied due to cluster policy.');\n    //     error.response = response;\n    //     error.json = json;\n    //     throw error;\n    //   });\n    // }\n    return response.json().then((json) => {\n        var _a, _b, _c;\n        // retry 409 conflict errors due to ClustResourceQuota / ResourceQuota\n        // https://bugzilla.redhat.com/show_bug.cgi?id=1920699\n        if (retry &&\n            method === 'POST' &&\n            response.status === 409 &&\n            ['resourcequotas', 'clusterresourcequotas'].includes((_a = json.details) === null || _a === void 0 ? void 0 : _a.kind)) {\n            throw new RetryError();\n        }\n        const cause = (_c = (_b = json.details) === null || _b === void 0 ? void 0 : _b.causes) === null || _c === void 0 ? void 0 : _c[0];\n        let reason;\n        if (cause) {\n            reason = `Error \"${cause.message}\" for field \"${cause.field}\".`;\n        }\n        if (!reason) {\n            reason = json.message;\n        }\n        if (!reason) {\n            reason = json.error;\n        }\n        if (!reason) {\n            reason = response.statusText;\n        }\n        const error = new Error(reason);\n        // error.response = response;\n        // error.json = json;\n        throw error;\n    });\n});\nexport const coFetchInternal = (url, options, timeout, retry) => __awaiter(void 0, void 0, void 0, function* () {\n    const allOptions = _.defaultsDeep({}, initDefaults, options);\n    if (allOptions.method !== 'GET') {\n        allOptions.headers['X-CSRFToken'] = getCSRFToken();\n    }\n    // If the URL being requested is absolute (and therefore, not a local request),\n    // remove the authorization header to prevent credentials from leaking.\n    if (url.indexOf('://') >= 0) {\n        delete allOptions.headers.Authorization;\n        delete allOptions.headers['X-CSRFToken'];\n    }\n    const fetchPromise = yield fetch(url, allOptions)\n        .then((response) => response.json())\n        .then((data) => {\n        console.log('DATA!!! is ' + data);\n        console.log(JSON.stringify(data));\n    });\n    // return fetch promise directly if timeout <= 0\n    if (timeout < 1) {\n        return fetchPromise;\n    }\n    const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n    // Initiate both the fetch promise and a timeout promise\n    return Promise.race([fetchPromise, timeoutPromise]);\n});\nexport const fetchAppGroups = (baseURL, manifestURL) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    let data;\n    try {\n        const newListApi = getApplicationsListBaseURI();\n        console.log('fetching ' + newListApi);\n        data = yield consoleFetchJSON(`${newListApi}?url=${manifestURL}?method=curl`);\n    }\n    catch (err) {\n        console.log('ERROR in fetch ' + err);\n        try {\n            data = yield consoleFetchJSON(`${baseURL}&url=${manifestURL}`);\n        }\n        catch (_b) { } // eslint-disable-line no-empty\n        // Ignore and let empty data be handled by fetchAllAppGroups\n    }\n    return (_a = data === null || data === void 0 ? void 0 : data.applications) !== null && _a !== void 0 ? _a : [];\n});\n// export const fetchAppGroups = async (\n//   baseURL: string,\n//   manifestURL: string,\n// ): Promise<GitOpsAppGroupData[]> => {\n//   let data: GitOpsManifestData;\n//   try {\n//     // const newListApi = getApplicationsListBaseURI();\n//     // const newListApi = 'https://cluster.openshift-gitops.svc:8080/applications';\n//     // const manifestURL = 'https://gitlab.com/keithchong/gitops5.git?ref=main';\n//     // let data2 = await Axios.get('http://localhost:9000/api/gitops/applications?url=https://gitlab.com/keithchong/gitops5.git?ref=HEAD');\n//     //https://cluster.openshift-gitops.svc:8080/api/gitops/applications');\n//     // console.log(\"****** DATA is \" + data);\n//     // let url = 'https://cluster.openshift-gitops.svc:8080/applications?url=https://gitlab.com/keithchong/gitops5.git?ref=HEAD';\n//     let url = 'api/gitops/applications?url=https://github.com/keithchong/gitops411.git?ref=HEAD';\n//     let options = {};\n//     let attempt = 0;\n//     let timeout = 60000;\n//     let response;\n//     let retry = true;\n//     while (retry) {\n//       retry = false;\n//       attempt++;\n//       try {\n//         response = await coFetchInternal(url, options, timeout, attempt < 3);\n//         data = await response.json();\n//         console.log(\"DATA!!! is \" + data);\n//         return data?.applications ?? [];\n//       } catch (e) {\n//         if (e instanceof RetryError) {\n//           retry = true;\n//         } else {\n//           // throw e;\n//         }\n//       }\n//     }\n//     console.log(\"****** DATA is \" + data);\n//     // data = await consoleFetchJSON(`${newListApi}?url=${manifestURL}`);\n//     // data = await consoleFetchJSON(url, \"GET\", options, timeout);\n//     // console.log(\"****** DATA is \" + stringify(data));\n//   } catch (err) {\n//     console.log(\"****** ERROR is \" + err);\n//     try {\n//       // data = await coFetchJSON(`${baseURL}&url=${manifestURL}`);\n//     } catch {} // eslint-disable-line no-empty\n//   }\n//   return data?.applications ?? [];\n// };\nexport const fetchAllAppGroups = (baseURL, manifestURLs, t) => __awaiter(void 0, void 0, void 0, function* () {\n    console.log('baseURLs: ', baseURL);\n    console.log('manifestURLs: ', manifestURLs);\n    let emptyMsg = null;\n    let allAppGroups = null;\n    console.log('Getting app groups ');\n    if (baseURL) {\n        if (_.isEmpty(manifestURLs)) {\n            emptyMsg = 'No GitOps manifest URLs found'; // t('gitops-plugin~No GitOps manifest URLs found');\n        }\n        else {\n            try {\n                allAppGroups = _.sortBy(_.flatten(yield Promise.all(_.map(manifestURLs, (manifestURL) => fetchAppGroups(baseURL, manifestURL)))), ['name']);\n            }\n            catch (_c) { } // eslint-disable-line no-empty\n            if (_.isEmpty(allAppGroups)) {\n                emptyMsg = 'gitops-plugin~No Application groups found'; // t('gitops-plugin~No Application groups found');\n            }\n        }\n    }\n    return [allAppGroups, emptyMsg];\n});\n// TODO\n// export const getEnvData = async (v2EnvURI: string, envURI: string, env: string, appURI: string) => {\n//   let data;\n//   try {\n//     data = await coFetchJSON(`${v2EnvURI}/${env}${appURI}`);\n//   } catch {\n//     try {\n//       data = await coFetchJSON(`${envURI}/${env}${appURI}`);\n//     } catch {} // eslint-disable-line no-empty\n//   }\n//   return data;\n// };\nexport const getPipelinesBaseURI = (secretNS, secretName) => {\n    return secretNS && secretName\n        ? `/api/gitops/pipelines?secretNS=${secretNS}&secretName=${secretName}`\n        : undefined;\n};\nexport const getArgoCDFilteredAppsURI = (argocdBaseUri, appGroupName) => {\n    return argocdBaseUri && appGroupName\n        ? `${argocdBaseUri}/applications?labels=app.kubernetes.io%252Fname%253D${appGroupName}`\n        : undefined;\n};\nexport const getApplicationsBaseURI = (appName, secretNS, secretName, manifestURL) => {\n    return secretNS && secretName\n        ? `/application/${appName}?secretNS=${secretNS}&secretName=${secretName}&url=${manifestURL}&app=${appName}`\n        : undefined;\n};\n"],"names":[],"sourceRoot":""}